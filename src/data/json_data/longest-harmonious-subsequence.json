{
  "title": "Longest Harmonious Subsequence",
  "slug": "longest-harmonious-subsequence",
  "leetcodeId": "#594",
  "category": [
    "Array",
    "Hash Map",
    "Sliding Window",
    "Sorting",
    "Frequency Count",
    "Two Pointer"
  ],
  "problemStatement": "We define a harmonious array as one where the difference between the maximum and minimum element is exactly 1. Given an array `nums`, return the length of the longest harmonious subsequence you can find. A subsequence can be formed by deleting some or no elements without changing the order of the remaining elements.",
  "examples": [
    {
      "input": "nums = [1, 3, 2, 2, 5, 2, 3, 7]",
      "output": "5",
      "explanation": "The subsequence [2, 2, 2, 3, 3] is the longest harmonious subsequence."
    },
    {
      "input": "nums = [1, 2, 3, 4]",
      "output": "2",
      "explanation": "Both [1, 2] and [2, 3] are valid, so the max is 2."
    },
    {
      "input": "nums = [1, 1, 1, 1]",
      "output": "0",
      "explanation": "No other number to pair with 1, so output is 0."
    }
  ],
  "approach": "Approach 1:\nSliding Window (Brute Force)\n\n1. Sort the array.\n2. Use two pointers `start` and `end` to slide over the array.\n3. If the difference between nums[end] and nums[start] > 1, move `start` forward.\n4. If the difference is exactly 1, calculate the window length and update max.\n\nApproach 2:\nOptimized HashMap\n\n1. Build a frequency map of all numbers.\n2. For each number in the map, check if `num + 1` exists.\n3. If yes, add `map[num] + map[num + 1]` and update the result.",
  "code": "// ðŸ”¹ Approach 1: Brute Force (Using Sliding Window)\nvar findLHS = function(nums) {\n  nums.sort((a, b) => a - b); // Sort the array\n  let start = 0, maxLen = 0;\n\n  for (let end = 0; end < nums.length; end++) {\n    while (nums[end] - nums[start] > 1) {\n      start++; // Shrink window if diff > 1\n    }\n    if (nums[end] - nums[start] === 1) {\n      maxLen = Math.max(maxLen, end - start + 1); // Update max length\n    }\n  }\n\n  return maxLen;\n};\n\nconsole.log(findLHS([1, 3, 2, 2, 5, 2, 3, 7])); // Output: 5\nconsole.log(findLHS([1, 2, 3, 4])); // Output: 2\n\n\n// ðŸ”¹ Approach 2: Optimized (Using Hash Map)\nvar findLHS = function(nums) {\n  const map = new Map();\n\n  for (let num of nums) {\n    map.set(num, (map.get(num) || 0) + 1); // Count frequency\n  }\n\n  let maxLen = 0;\n  for (let [num, count] of map.entries()) {\n    if (map.has(num + 1)) {\n      maxLen = Math.max(maxLen, count + map.get(num + 1)); // Combine with neighbor\n    }\n  }\n\n  return maxLen;\n};\n\nconsole.log(findLHS([1, 3, 2, 2, 5, 2, 3, 7])); // Output: 5\nconsole.log(findLHS([1, 2, 3, 4])); // Output: 2",
  "timeComplexity": "Brute Force: O(n log n) due to sorting. Optimized: O(n) using hash map.",
  "spaceComplexity": "Brute Force: O(1) or O(n) (depends on sort). Optimized: O(n) for the frequency map.",
  "leetcodeLink": "https://leetcode.com/problems/longest-harmonious-subsequence/",
  "pptLink": "https://1drv.ms/p/c/d9a1d5f2dacf7aea/IQRiCaf_x8_GTLdrRpBXXLO_ARt9S5TYhQweBDxnCpim570?em=2&amp;wdAr=1.7777777777777777",
  "videoLink": "oA9UBaWCL5I"
}
